# Copyright Â© 2017-2021 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

_multipass_complete()
{
    _multipass_instances()
    {
        local state=$1

        local cmd="multipass list --format=csv --no-ipv4"
        [ -n "$state" ] && cmd="$cmd | \grep -E '$state'"

        local instances=$( \eval $cmd | \grep -Ev '(\+--|Name)' | \cut -d',' -f 1 )

        local found

        _get_comp_words_by_ref -n := -w WORDS -i CWORD cur prev
        for instance in $instances; do
            found=0
            for ((i=2; i<CWORD; i++)); do
                if [[ "${WORDS[i]}" == ${instance} ]]; then
                    found=1
                    break
                fi
            done
            if [ ${found} == 0 ]; then
                opts="${opts} ${instance}"
            fi
        done
    }

    # Set $opts to the list of available networks.
    _multipass_networks()
    {
        local cmd="multipass networks --format=csv 2>/dev/null"

        opts=$( \eval $cmd | \grep -Ev '(\+--|Name)' | \cut -d',' -f 1 )
    }

    # Removes the comma or equals sign at the end of $cur.
    _remove_trailing_char()
    {
        if [[ $cur =~ [,=]$ ]]; then
            cur="${cur#*[,=]}"
            return 0
        fi

        return 1
    }

    # When options for --network are specified in the form var=val, this function sets $opts to the values needed
    # depending on the value of var (which is specified as the parameter $1).
    _complete_network_var()
    {
        case "$1" in
            "id")
                _multipass_networks
            ;;
            "mac")
                opts=""
            ;;
            "mode")
                opts="auto manual"
            ;;
        esac
    }

    # Find the position of the last appearance of a given parameter name in the command-line. Return its index, or
    # 0 if not found.
    _find_last_par()
    {
        local last_pos

        for ((last_pos=COMP_CWORD; last_pos>0; --last_pos)); do
            if [[ "${COMP_WORDS[$last_pos]}" == "$1" ]]; then
                break
            fi
        done

        return ${last_pos}
    }

    # Find the position of the last appearance of parameter starting with "--" in the command-line. Return its
    # index, or 0 if not found.
    _find_last_dashdash()
    {
        local last_pos

        for ((last_pos=COMP_CWORD; last_pos>0; --last_pos)); do
            if [[ "${COMP_WORDS[$last_pos]}" =~ ^--.* ]]; then
                break
            fi
        done

        return ${last_pos}
    }

    # Sets $1 to the name of the last argument whose name starts with "--", or the empty string if there is none.
    _last_dashdash_name()
    {
        local last_pos

        last_dashdash_arg=""
        for ((last_pos=COMP_CWORD; last_pos>0; --last_pos)); do
            if [[ "${COMP_WORDS[$last_pos]}" =~ ^--.* ]]; then
                last_dashdash_arg=${COMP_WORDS[$last_pos]}
                break
            fi
        done
    }

    # If the last argument starting with "--" is "--network", scan from there until the end of the command-line for
    # the names of the variables which were already specified. And fill-in $opts with the variables which were not
    # yet specified.
    # TODO: In case of adding more parameters starting with "--", factor out this function and take as parameters
    # an argument name and the list of possible "var=" keys. Calling this function would then look like
    # _unspecified_vars "--network" ("id= mac= mode=")
    _unspecified_network_vars()
    {
        local last_network_pos=$(_find_last_par "--network")

        local last_dashdash_pos=$(_find_last_dashdash)

        opts=""

        if [[ ${last_network_pos} == ${last_dashdash_pos} ]]; then
            local id_found=0
            local mac_found=0
            local mode_found=0

            for ((i=${last_network_pos}+1; i<COMP_CWORD; ++i)); do
                if [[ "${COMP_WORDS[$i]}" == 'id' ]]; then id_found=1; fi
                if [[ "${COMP_WORDS[$i]}" == 'mac' ]]; then mac_found=1; fi
                if [[ "${COMP_WORDS[$i]}" == 'mode' ]]; then mode_found=1; fi
            done

            if [[ ${id_found} == 0 ]]; then opts="${opts} id="; fi
            if [[ ${mac_found} == 0 ]]; then opts="${opts} mac="; fi
            if [[ ${mode_found} == 0 ]]; then opts="${opts} mode="; fi
        fi
    }

    # Add the comma to the list of word separators, useful to separate options of the form "opt1=val1,opt2=val2".
    COMP_WORDBREAKS="${COMP_WORDBREAKS},"

    local cur cmd opts prev prev_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    prev2="${COMP_WORDS[COMP_CWORD-2]}"
    cmd="${COMP_WORDS[1]}"
    prev_opts=false
    multipass_cmds="transfer delete exec find help info launch list mount networks \
                    purge recover shell start stop suspend restart umount version get set"

    opts="--help --verbose"
    case "${cmd}" in
        "info")
            opts="${opts} --all --format"
        ;;
        "list"|"ls")
            opts="${opts} --format"
        ;;
        "networks")
            opts="${opts} --format"
        ;;
        "delete")
            opts="${opts} --all --purge"
        ;;
        "launch")
            opts="${opts} --cpus --disk --mem --name --cloud-init --network"
        ;;
        "mount")
            opts="${opts} --gid-map --uid-map"
        ;;
        "recover"|"start"|"suspend"|"restart")
            opts="${opts} --all"
        ;;
        "stop")
            opts="${opts} --all --cancel --time"
        ;;
        "find")
            opts="${opts} --show-unsupported --format"
        ;;
    esac

    if [[ ${prev} == -* ]]; then
        case "${prev}" in
            "--format"|"-f")
                opts="table json csv yaml"
                prev_opts=true
            ;;
            "--cloud-init")
                _filedir
                return
            ;;
            "--network")
                _multipass_networks
                if [[ "${opts}" != "" ]]; then
                    opts="${opts} id= mode= mac="
                fi
                # TODO: Do use spaces after the completion of an interface name.
                compopt -o nospace
        esac
    else
        local last_dashdash_arg
        _last_dashdash_name

        if [[ ${last_dashdash_arg} == "--network" ]]; then
            # We need to complete the option pairs in two steps. One, when the last input char was an equals sign. Two,
            # when the user starts to input something, because prev changes when she starts to type a value.
            if [[ "${cur}" == '=' ]] && [[ "${prev2}" == ',' || "${prev2}" == '--network' ]] ; then
                compopt -o nospace
                _remove_trailing_char
                _complete_network_var "${prev}"

            elif [[ "${prev}" == '=' ]]; then
                compopt -o nospace
                _complete_network_var "${prev2}"

            # Complete now in the case on which there is a comma separating var=val pairs.
            elif [[ "${cur}" == ',' && "${prev2}" == '=' ]] ||
                 [[ "${prev}" == ',' && "${COMP_WORDS[COMP_CWORD-3]}" == '=' ]]; then
                _remove_trailing_char
                compopt -o nospace
                _unspecified_network_vars
            fi
        fi
    fi

    if [[ "$prev_opts" = false ]]; then
        case "${cmd}" in
            "exec"|"stop"|"suspend"|"restart")
                _multipass_instances "Running"
            ;;
            "connect"|"sh"|"shell")
                _multipass_instances "Running"
                _multipass_instances "Stopped"
                _multipass_instances "Suspended"
            ;;
            "start")
                _multipass_instances "Stopped"
                _multipass_instances "Suspended"
            ;;
            "delete"|"info"|"umount"|"unmount")
                _multipass_instances
            ;;
            "recover")
                _multipass_instances "Deleted"
            ;;
            "mount")
                local source_set=0
                local prev
                _get_comp_words_by_ref -n := -w WORDS -i CWORD cur prev
                # Scan through the current command line to detect if the source
                # positional arg has been set.
                for ((i=2; i<CWORD; i++)); do
                    if [[ "${WORDS[i]}" != -* ]] && \
                       ([[ "${WORDS[i-1]}" != -* ]] || [[ "${WORDS[i-1]}" == *=* ]]); then
                            source_set=1
                            break
                    fi
                done

                if [ ${source_set} == 0 ] ; then
                    if [[ ${prev} != -* ]] || ([[ ${prev} == -* ]] && [[ ${prev} == *=* ]]); then
                        _filedir -d
                        return
                    fi
                elif [ ${source_set} == 1 ] && [[ ${prev} != -* ]]; then
                    _multipass_instances "Running"
                    _multipass_instances "Stopped"
                    _multipass_instances "Suspended"
                fi
            ;;
            "transfer"|"copy-files")
                _multipass_instances "Running"

                COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
                if [[ "${#COMPREPLY[@]}" == "0" ]]; then
                    _filedir
                    return
                fi
            ;;
            "help")
                opts=$multipass_cmds
            ;;
        esac
    fi

    if [[ ${COMP_CWORD} -eq 1 ]]; then
        opts="${opts} ${multipass_cmds}"
    fi

    if [[ -n "${opts}" ]]; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
    fi

    return 0
}
complete -F _multipass_complete multipass
